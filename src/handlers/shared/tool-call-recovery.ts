/**
 * Tool Call Recovery Module
 *
 * Handles recovery from malformed tool calls generated by local models.
 * Implements multiple strategies:
 * 1. Text-based tool call extraction (parse JSON/XML from text)
 * 2. Parameter inference for missing required fields
 * 3. Retry prompt generation with error feedback
 */

import { log } from "../../logger.js";

export interface ExtractedToolCall {
  name: string;
  arguments: Record<string, any>;
  source: "structured" | "json_text" | "xml_text" | "inferred";
}

export interface ToolSchema {
  name: string;
  description?: string;
  input_schema?: {
    type: string;
    properties?: Record<string, any>;
    required?: string[];
  };
}

/**
 * Extract tool calls from text content
 * Many local models output tool calls as JSON in their text rather than using structured tool_calls
 */
export function extractToolCallsFromText(text: string): ExtractedToolCall[] {
  const extracted: ExtractedToolCall[] = [];

  // Pattern 0: Qwen-style function calls <function=NAME><parameter=PARAM>VALUE
  // Example: <function=SlashCommand><parameter=command>/ls -la
  const qwenPattern = /<function=([^>]+)>([\s\S]*?)(?=<function=|$)/gi;
  let match;
  while ((match = qwenPattern.exec(text)) !== null) {
    const funcName = match[1];
    const paramsText = match[2];
    const args: Record<string, any> = {};

    // Extract parameters: <parameter=name>value
    const paramPattern = /<parameter=([^>]+)>\s*([\s\S]*?)(?=<parameter=|<function=|$)/gi;
    let paramMatch;
    while ((paramMatch = paramPattern.exec(paramsText)) !== null) {
      const paramName = paramMatch[1];
      const paramValue = paramMatch[2].trim();
      args[paramName] = paramValue;
    }

    if (funcName) {
      extracted.push({
        name: funcName,
        arguments: args,
        source: "xml_text",
      });
      log(`[ToolRecovery] Extracted Qwen-style tool call: ${funcName}`);
    }
  }

  // Pattern 1: XML-style tool calls <tool_call>{"name": "...", "arguments": {...}}</tool_call>
  const xmlPattern = /<tool_call>\s*(\{[\s\S]*?\})\s*<\/tool_call>/gi;
  while ((match = xmlPattern.exec(text)) !== null) {
    try {
      const parsed = JSON.parse(match[1]);
      if (parsed.name) {
        extracted.push({
          name: parsed.name,
          arguments: parsed.arguments || parsed.input || parsed.parameters || {},
          source: "xml_text",
        });
      }
    } catch (e) {
      // Continue trying other patterns
    }
  }

  // Pattern 2: Function call format {"name": "tool_name", "arguments": {...}}
  const funcCallPattern =
    /\{\s*"name"\s*:\s*"([^"]+)"\s*,\s*"(?:arguments|input|parameters)"\s*:\s*(\{[\s\S]*?\})\s*\}/gi;
  while ((match = funcCallPattern.exec(text)) !== null) {
    try {
      const args = JSON.parse(match[2]);
      extracted.push({
        name: match[1],
        arguments: args,
        source: "json_text",
      });
    } catch (e) {
      // Continue
    }
  }

  // Pattern 2b: Alternative format {"tool": "tool_name", "tool_input": {...}}
  // Some models (like Qwen) output this format instead
  const toolInputPattern =
    /\{\s*"tool"\s*:\s*"([^"]+)"\s*,\s*"tool_input"\s*:\s*(\{[\s\S]*?\})\s*\}/gi;
  while ((match = toolInputPattern.exec(text)) !== null) {
    try {
      const args = JSON.parse(match[2]);
      extracted.push({
        name: match[1],
        arguments: args,
        source: "json_text",
      });
      log(`[ToolRecovery] Extracted tool/tool_input format: ${match[1]}`);
    } catch (e) {
      // Continue
    }
  }

  // Pattern 3: Anthropic-style tool_use blocks in text
  const anthropicPattern =
    /\{\s*"type"\s*:\s*"tool_use"\s*,\s*"id"\s*:\s*"[^"]*"\s*,\s*"name"\s*:\s*"([^"]+)"\s*,\s*"input"\s*:\s*(\{[\s\S]*?\})\s*\}/gi;
  while ((match = anthropicPattern.exec(text)) !== null) {
    try {
      const args = JSON.parse(match[2]);
      extracted.push({
        name: match[1],
        arguments: args,
        source: "json_text",
      });
    } catch (e) {
      // Continue
    }
  }

  // Pattern 3b: OpenAI tool_call format in array
  // [{"type":"tool_call","id":"...","tool_call":{"name":"...","arguments":{...}}}]
  const openaiArrayPattern =
    /\{\s*"type"\s*:\s*"tool_call"\s*,\s*"id"\s*:\s*"[^"]*"\s*,\s*"tool_call"\s*:\s*\{\s*"name"\s*:\s*"([^"]+)"\s*,\s*"arguments"\s*:\s*(\{[\s\S]*?\})\s*\}\s*\}/gi;
  while ((match = openaiArrayPattern.exec(text)) !== null) {
    try {
      const args = JSON.parse(match[2]);
      extracted.push({
        name: match[1],
        arguments: args,
        source: "json_text",
      });
      log(`[ToolRecovery] Extracted OpenAI tool_call format: ${match[1]}`);
    } catch (e) {
      // Continue
    }
  }

  // Pattern 4: Simple JSON objects that look like tool calls (heuristic)
  // Look for JSON with common tool parameter names
  const jsonBlockPattern = /```(?:json)?\s*(\{[\s\S]*?\})\s*```/gi;
  while ((match = jsonBlockPattern.exec(text)) !== null) {
    try {
      const parsed = JSON.parse(match[1]);
      // Check if it looks like a tool call
      if (parsed.name && (parsed.arguments || parsed.input || parsed.parameters)) {
        extracted.push({
          name: parsed.name,
          arguments: parsed.arguments || parsed.input || parsed.parameters,
          source: "json_text",
        });
      }
    } catch (e) {
      // Continue
    }
  }

  // Pattern 5: Natural language tool intent extraction
  // Matches: "I'll use the Task tool with subagent_type=Explore"
  // Matches: "I will use the Read tool to read /path/to/file"
  // Matches: "Let me use the Bash tool to run ls -la"
  const knownTools = [
    "Task",
    "Read",
    "Write",
    "Edit",
    "Bash",
    "Grep",
    "Glob",
    "WebFetch",
    "WebSearch",
  ];
  const nlPatterns = [
    // "I'll use the X tool with param=value" - ends with period, colon, newline, or end
    /(?:I(?:'ll| will| am going to)|Let me|Going to)\s+use\s+(?:the\s+)?(\w+)\s+tool\s+(?:with\s+)?(.+?)(?:[.:\n]|$)/gi,
    // "use X tool to do something"
    /use\s+(?:the\s+)?(\w+)\s+tool\s+(?:to\s+)?(.+?)(?:[.:\n]|$)/gi,
  ];

  for (const pattern of nlPatterns) {
    pattern.lastIndex = 0; // Reset regex state
    while ((match = pattern.exec(text)) !== null) {
      const toolName = match[1];
      const paramText = match[2];

      // Only extract if it's a known tool
      if (!knownTools.some((t) => t.toLowerCase() === toolName.toLowerCase())) {
        continue;
      }

      // Normalize tool name
      const normalizedToolName =
        knownTools.find((t) => t.toLowerCase() === toolName.toLowerCase()) || toolName;
      const args: Record<string, any> = {};

      // Extract key=value pairs
      const kvPattern = /(\w+)\s*=\s*["']?([^"',\s]+)["']?/g;
      let kvMatch;
      while ((kvMatch = kvPattern.exec(paramText)) !== null) {
        args[kvMatch[1]] = kvMatch[2];
      }

      // Extract quoted strings as potential file paths or commands
      const quotedPattern = /["']([^"']+)["']/g;
      let quotedMatch;
      const quotedValues: string[] = [];
      while ((quotedMatch = quotedPattern.exec(paramText)) !== null) {
        quotedValues.push(quotedMatch[1]);
      }

      // Tool-specific parameter extraction from natural language
      if (normalizedToolName === "Task") {
        // Look for subagent_type mentions
        if (!args.subagent_type) {
          const stMatch = paramText.match(/subagent_type\s*[=:]\s*["']?(\w+)["']?/i);
          if (stMatch) {
            args.subagent_type = stMatch[1];
          } else if (/explore|codebase|structure/i.test(paramText)) {
            args.subagent_type = "Explore";
          } else if (/plan|architect/i.test(paramText)) {
            args.subagent_type = "Plan";
          } else {
            args.subagent_type = "general-purpose";
          }
        }
        // Extract task intent as prompt
        if (!args.prompt) {
          // Use the text after "to" as the prompt
          const toMatch = paramText.match(/\bto\s+(.+)/i);
          if (toMatch) {
            args.prompt = toMatch[1].trim();
          } else {
            args.prompt = paramText.trim();
          }
        }
        if (!args.description) {
          args.description = (args.prompt || paramText).substring(0, 50).trim();
        }
      } else if (normalizedToolName === "Read") {
        // Extract file path
        if (!args.file_path) {
          if (quotedValues.length > 0) {
            args.file_path = quotedValues[0];
          } else {
            // Look for path-like strings
            const pathMatch = paramText.match(/(?:read|file)\s+([\/\w.-]+)/i);
            if (pathMatch) {
              args.file_path = pathMatch[1];
            }
          }
        }
      } else if (normalizedToolName === "Bash") {
        // Extract command
        if (!args.command) {
          if (quotedValues.length > 0) {
            args.command = quotedValues[0];
          } else {
            // Look for "run X" or "execute X"
            const cmdMatch = paramText.match(/(?:run|execute)\s+(.+)/i);
            if (cmdMatch) {
              args.command = cmdMatch[1].trim();
            }
          }
        }
        if (args.command && !args.description) {
          args.description = `Run ${args.command.split(" ")[0]} command`;
        }
      } else if (normalizedToolName === "Grep" || normalizedToolName === "Glob") {
        // Extract pattern
        if (!args.pattern) {
          if (quotedValues.length > 0) {
            args.pattern = quotedValues[0];
          } else {
            const searchMatch = paramText.match(/(?:search|find|look for)\s+(.+)/i);
            if (searchMatch) {
              args.pattern = searchMatch[1].trim();
            }
          }
        }
      }

      // Only add if we extracted meaningful arguments
      if (Object.keys(args).length > 0) {
        extracted.push({
          name: normalizedToolName,
          arguments: args,
          source: "inferred",
        });
        log(
          `[ToolRecovery] Extracted natural language tool intent: ${normalizedToolName} with args: ${JSON.stringify(args)}`
        );
      }
    }
  }

  return extracted;
}

/**
 * Infer missing parameters for known tools
 */
export function inferMissingParameters(
  toolName: string,
  args: Record<string, any>,
  missingParams: string[],
  context?: string
): Record<string, any> {
  const inferred = { ...args };

  // Task tool inference
  if (toolName === "Task") {
    // Valid subagent types
    const validSubagentTypes = [
      "general-purpose",
      "Explore",
      "Plan",
      "claude-code-guide",
      "code-analysis:detective",
      "feature-dev:code-architect",
      "feature-dev:code-explorer",
      "feature-dev:code-reviewer",
    ];

    // Normalize subagent_type - models often use variations
    if (inferred.subagent_type) {
      const st = inferred.subagent_type.toLowerCase();
      // Map common variations to valid types
      if (st.includes("explore") || st.includes("codebase") || st.includes("file")) {
        inferred.subagent_type = "Explore";
      } else if (st.includes("plan") || st.includes("architect")) {
        inferred.subagent_type = "Plan";
      } else if (
        st.includes("analysis") ||
        st.includes("analyz") ||
        st.includes("config") ||
        st.includes("git") ||
        st.includes("test") ||
        st.includes("doc") ||
        st.includes("version")
      ) {
        inferred.subagent_type = "general-purpose";
      } else if (!validSubagentTypes.includes(inferred.subagent_type)) {
        log(
          `[ToolRecovery] Unknown subagent_type "${inferred.subagent_type}", mapping to general-purpose`
        );
        inferred.subagent_type = "general-purpose";
      }
    }

    if (missingParams.includes("subagent_type") && !inferred.subagent_type) {
      // Default to general-purpose if not specified
      inferred.subagent_type = "general-purpose";
      log(`[ToolRecovery] Inferred subagent_type: general-purpose`);
    }

    // Try to extract meaningful task description from context
    let extractedTask = "";
    if (context) {
      // Look for common patterns that indicate the model's intent
      const patterns = [
        /(?:I(?:'ll| will| need to| want to| am going to)|Let me|Going to)\s+([^.!?\n]+)/i,
        /(?:help you|assist with)\s+([^.!?\n]+)/i,
        /(?:explore|search|find|look for|investigate)\s+([^.!?\n]+)/i,
        /(?:implement|create|build|add|fix|update)\s+([^.!?\n]+)/i,
      ];
      for (const pattern of patterns) {
        const match = context.match(pattern);
        if (match && match[1] && match[1].length > 10) {
          extractedTask = match[1].trim();
          log(`[ToolRecovery] Extracted task from context: "${extractedTask.substring(0, 50)}..."`);
          break;
        }
      }
      // Fallback: use the last meaningful sentence as context
      if (!extractedTask && context.length > 20) {
        const sentences = context.split(/[.!?\n]+/).filter((s) => s.trim().length > 15);
        if (sentences.length > 0) {
          extractedTask = sentences[sentences.length - 1].trim();
        }
      }
    }

    if (missingParams.includes("prompt") && !inferred.prompt) {
      // Try to use description, task content, query, or extracted context
      // Some models use "query" instead of "prompt"
      if (inferred.query) {
        inferred.prompt = inferred.query;
        log(`[ToolRecovery] Mapped query -> prompt: "${inferred.query.substring(0, 50)}..."`);
      } else if (inferred.description && inferred.description !== "Execute task") {
        inferred.prompt = inferred.description;
      } else if (inferred.task) {
        inferred.prompt = inferred.task;
      } else if (extractedTask) {
        inferred.prompt = extractedTask;
      } else if (context && context.length > 20) {
        // Use the full context if nothing else works
        inferred.prompt = context.substring(0, 500).trim();
      }
      if (inferred.prompt) {
        log(`[ToolRecovery] Inferred prompt: "${inferred.prompt.substring(0, 50)}..."`);
      }
    }

    if (missingParams.includes("description") && !inferred.description) {
      // Generate description from prompt or extracted task
      if (inferred.prompt) {
        // Take first 50 chars of prompt as description
        inferred.description = inferred.prompt.substring(0, 50).replace(/\s+/g, " ").trim();
        if (inferred.description.length < inferred.prompt.length) {
          inferred.description += "...";
        }
      } else if (extractedTask) {
        inferred.description = extractedTask.substring(0, 50).trim();
      } else {
        inferred.description = "Execute task";
      }
      log(`[ToolRecovery] Inferred description: ${inferred.description}`);
    }
  }

  // Bash tool inference
  if (toolName === "Bash") {
    if (missingParams.includes("command") && !inferred.command) {
      // Check for common alternative parameter names
      inferred.command = inferred.cmd || inferred.shell || inferred.script || "";
    }
    if (missingParams.includes("description") && !inferred.description) {
      if (inferred.command) {
        // Generate description from command
        const cmd = inferred.command.split(" ")[0];
        inferred.description = `Run ${cmd} command`;
      }
    }
  }

  // Read tool inference
  if (toolName === "Read") {
    if (missingParams.includes("file_path") && !inferred.file_path) {
      inferred.file_path = inferred.path || inferred.file || inferred.filename || "";
    }
  }

  // Write tool inference
  if (toolName === "Write") {
    if (missingParams.includes("file_path") && !inferred.file_path) {
      inferred.file_path = inferred.path || inferred.file || inferred.filename || "";
    }
    if (missingParams.includes("content") && !inferred.content) {
      inferred.content = inferred.text || inferred.data || inferred.body || "";
    }
  }

  // Grep tool inference
  if (toolName === "Grep") {
    if (missingParams.includes("pattern") && !inferred.pattern) {
      inferred.pattern = inferred.query || inferred.search || inferred.regex || "";
    }
  }

  // Glob tool inference
  if (toolName === "Glob") {
    if (missingParams.includes("pattern") && !inferred.pattern) {
      inferred.pattern = inferred.glob || inferred.path || inferred.search || "**/*";
    }
  }

  return inferred;
}

/**
 * Generate a retry prompt with error feedback
 */
export function generateRetryPrompt(
  toolName: string,
  missingParams: string[],
  providedArgs: Record<string, any>,
  toolSchema?: ToolSchema
): string {
  let prompt = `Your previous tool call to "${toolName}" was incomplete. `;
  prompt += `Missing required parameters: ${missingParams.join(", ")}.\n\n`;

  if (toolSchema?.input_schema?.properties) {
    prompt += `The ${toolName} tool requires:\n`;
    for (const param of missingParams) {
      const propSchema = toolSchema.input_schema.properties[param];
      if (propSchema) {
        prompt += `- ${param}: ${propSchema.description || propSchema.type || "required"}\n`;
      } else {
        prompt += `- ${param}: required\n`;
      }
    }
    prompt += "\n";
  }

  prompt += `You provided: ${JSON.stringify(providedArgs, null, 2)}\n\n`;
  prompt += `Please try again with ALL required parameters included.`;

  return prompt;
}

/**
 * Check if a tool call can be repaired
 */
export function canRepairToolCall(
  toolName: string,
  args: Record<string, any>,
  missingParams: string[]
): boolean {
  // Check if we have enough context to infer the missing params
  const inferred = inferMissingParameters(toolName, args, missingParams);

  // Verify all missing params are now present
  for (const param of missingParams) {
    if (!inferred[param] || inferred[param] === "") {
      return false;
    }
  }

  return true;
}

/**
 * Get tool calling guidance to add to system prompt for local models
 */
export function getToolCallingGuidance(): string {
  return `
IMPORTANT TOOL CALLING INSTRUCTIONS:
When calling tools/functions, you MUST include ALL required parameters. Incomplete tool calls will fail.

For the Task tool, you MUST always provide:
- description: A short (3-5 word) description of the task
- prompt: The detailed task instructions
- subagent_type: The type of agent (e.g., "general-purpose", "Explore", "Plan")

For the Bash tool, you MUST always provide:
- command: The shell command to execute
- description: A brief description of what the command does

For file tools (Read, Write, Edit), always provide the full file_path.

Format your tool calls as valid JSON with all required fields populated.
`;
}

/**
 * Validate and potentially repair a tool call
 * Returns the repaired arguments if successful, null if repair failed
 */
export function validateAndRepairToolCall(
  toolName: string,
  argsStr: string,
  toolSchemas: ToolSchema[],
  textContent?: string
): {
  valid: boolean;
  args: Record<string, any>;
  repaired: boolean;
  missingParams: string[];
} {
  const schema = toolSchemas.find((t) => t.name === toolName);
  if (!schema?.input_schema) {
    return { valid: true, args: {}, repaired: false, missingParams: [] };
  }

  let parsedArgs: Record<string, any> = {};
  try {
    parsedArgs = argsStr ? JSON.parse(argsStr) : {};
  } catch (e) {
    // Try to extract from text if structured parsing failed
    if (textContent) {
      const extracted = extractToolCallsFromText(textContent);
      const matching = extracted.find((tc) => tc.name === toolName);
      if (matching) {
        parsedArgs = matching.arguments;
        log(`[ToolRecovery] Extracted tool args from text for ${toolName}`);
      }
    }
  }

  const required = schema.input_schema.required || [];
  const missingParams = required.filter(
    (param) =>
      parsedArgs[param] === undefined || parsedArgs[param] === null || parsedArgs[param] === ""
  );

  if (missingParams.length === 0) {
    return { valid: true, args: parsedArgs, repaired: false, missingParams: [] };
  }

  // Try to infer missing parameters
  const repairedArgs = inferMissingParameters(toolName, parsedArgs, missingParams, textContent);

  // Check if repair was successful
  const stillMissing = required.filter(
    (param) =>
      repairedArgs[param] === undefined ||
      repairedArgs[param] === null ||
      repairedArgs[param] === ""
  );

  if (stillMissing.length === 0) {
    log(`[ToolRecovery] Successfully repaired tool call ${toolName}`);
    return { valid: true, args: repairedArgs, repaired: true, missingParams: [] };
  }

  return { valid: false, args: repairedArgs, repaired: false, missingParams: stillMissing };
}
